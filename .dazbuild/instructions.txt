# Dazbuild Instructions

## End Change Validation Rules
When you call `dazbuild_end_change`, the following checks must pass:

1. **Pylint Score**: Must be 10/10 with no errors or warnings
2. **Unit Tests**: All tests must pass via `python -m unittest discover`
3. **Test Coverage**: Every .py file must contain at least one unittest.TestCase test
4. **No unittest.main()**: Files cannot invoke unittest.main() directly
5. **File Size Limit**: All code files must be smaller than 8192 bytes

## Code Quality Philosophy

### NEVER Optimize by Trimming Code
- **CRITICAL**: Never reduce file size by removing comments, shortening variable names, compacting formatting, or removing functionality
- **CRITICAL**: Never trim verbose code examples or documentation to meet size limits
- **CRITICAL**: Clean, verbose, readable code is THE TOP PRIORITY - never compromise this

### File Size Management - The RIGHT Way
- **When files exceed 8192 bytes**: ALWAYS refactor into multiple logical smaller files
- **Split by logical boundaries**: Create separate files for related functionality
- **Common refactoring patterns**:
  - Extract utility functions into `*_utils.py`
  - Split large classes into focused smaller classes
  - Create separate modules for different concerns (e.g., `*_processor.py`, `*_chat.py`, `*_viewer.py`)
  - Move test classes to separate test files if needed
- **Example**: If `script.js` is too large, split into `viewer.js`, `editor.js`, `ui.js`, etc.

## Best Practices for Using Dazbuild

### Work with Small References
- Always edit at the **smallest hierarchy node** possible
- Instead of rewriting entire files, target specific functions, methods, or classes
- Use `dazbuild_outline` to see the structure and find the right reference
- Example: Edit `myfile.py::MyClass::my_method` instead of `myfile.py`

### Workflow Pattern
1. `dazbuild_start_change` - Begin your change session
2. Use `dazbuild_get` to examine current code
3. Use `dazbuild_write` or `dazbuild_add` for targeted changes
4. `dazbuild_end_change` - Validate and commit

### Refactoring for Size Limits
- **Step 1**: Identify logical boundaries in the oversized file
- **Step 2**: Create new focused files for each logical group
- **Step 3**: Move code maintaining all functionality and verbose style
- **Step 4**: Update imports appropriately
- **Step 5**: Ensure all tests still pass

### Import Handling
- **Direct Execution vs Module Imports**: When files need to run both as scripts and as modules, use this pattern:
  ```python
  try:
      from .module_name import function_name
  except ImportError:
      # Fallback for direct execution
      from module_name import function_name
  ```
- **Optional Dependencies**: Handle external libraries gracefully:
  ```python
  try:
      import optional_library
      LIBRARY_AVAILABLE = True
  except ImportError:
      LIBRARY_AVAILABLE = False
  ```

### Testing Strategy
- Add real unit tests to every Python file (no mocks unless necessary)
- Test both happy path and edge cases
- Keep test methods focused and well-named
- **When Refactoring**: Update test imports when moving functions between modules
- **Pattern**: Test moved functions through their new module: `new_module.function_name()`

### Code Quality Standards
- Write clean, verbose, readable code that passes pylint
- Use meaningful, descriptive variable and function names
- Add comprehensive docstrings for public methods and classes
- Keep functions focused on a single responsibility
- **Preserve Comments**: Keep all explanatory comments and documentation
- **Verbose Examples**: Maintain clear, well-commented example code
- **Remove Unused Imports**: Pylint will catch these - clean them up promptly

### Framework Preservation
- **Respect Existing Architecture**: Don't change async frameworks (Sanic) to sync frameworks (Flask) without explicit permission
- **Maintain Async Patterns**: Keep `async def` functions and `await` calls when working with async frameworks
- **Add Routes Correctly**: For Sanic, use `@app.route()` decorators properly

## Architectural Principles

### Backend Purity Rule
- **CRITICAL**: Backend should never be tailored to specific frontend technologies (Three.js, WebGL, etc.)
- **Backend Role**: Output data in the native format of the source framework (CadQuery, OpenCascade, etc.)
- **Frontend Role**: Adapt backend data to whatever rendering library is being used
- **Reason**: Maintains flexibility for future frontend changes and proper separation of concerns
- **Example**: CadQuery transformation matrices should stay in OpenCascade format; Three.js frontend adapts them

### Progressive Error Resolution
When `dazbuild_end_change` fails, fix issues in this order:
1. **File Size**: Extract large files into focused modules first (NEVER trim code)
2. **Pylint Issues**: Fix trailing whitespace, unused imports, line length
3. **Import Errors**: Add fallback imports for direct execution
4. **Test Failures**: Update test imports after refactoring
5. **Missing Functions**: Ensure all referenced functions exist in correct modules

### External Integration Patterns
- **LLM Integration**: Use structured responses with Pydantic models
- **Iterative Processing**: Implement retry loops with error accumulation
- **Graceful Degradation**: Provide fallbacks when external services unavailable
- **Error Context**: Include previous errors in retry attempts for better results

## File Size Crisis Response Protocol
If a file exceeds the 8192 byte limit:

1. **STOP**: Do not trim, compact, or remove any code
2. **ANALYZE**: Identify logical boundaries in the file
3. **PLAN**: Design how to split into smaller, focused files
4. **REFACTOR**: Create new files and move code groups
5. **TEST**: Ensure all functionality remains intact
6. **MAINTAIN**: Keep all verbose code, comments, and examples

Remember: Readable, maintainable code is worth more than any size optimization.