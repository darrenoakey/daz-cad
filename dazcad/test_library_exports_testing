"""Export testing functionality for library files."""

import unittest
from typing import List, Dict, Any
from pathlib import Path

try:
    from .export_utils import (get_supported_export_formats, export_shape_to_format,
                              export_assembly_to_format)
    from .test_library_exports_core import LibraryExecutor
except ImportError:
    # Fallback for direct execution
    from export_utils import (get_supported_export_formats, export_shape_to_format,
                             export_assembly_to_format)
    from test_library_exports_core import LibraryExecutor

try:
    import cadquery as cq
    CADQUERY_AVAILABLE = True
except ImportError:
    CADQUERY_AVAILABLE = False


class LibraryExportTester:
    """Handles testing of library file exports."""

    def __init__(self, library_path: Path):
        """Initialize the export tester."""
        self.library_path = library_path
        self.executor = LibraryExecutor(library_path)
        self.supported_formats = (list(get_supported_export_formats().values())
                                 if CADQUERY_AVAILABLE else [])

    def perform_export_test(self, obj, obj_type, format_name, export_key):
        """Perform export test for a single object and format."""
        try:
            # Perform the export
            if obj_type == 'assembly':
                data = export_assembly_to_format(obj, format_name)
            else:
                data = export_shape_to_format(obj, format_name)

            # Verify export result
            if not isinstance(data, bytes):
                return False, f"Export did not return bytes: {export_key}"

            if len(data) == 0:
                return False, f"Export returned empty data: {export_key}"

            # Additional sanity check - verify it's not just whitespace
            if len(data.strip()) == 0:
                return False, f"Export returned only whitespace: {export_key}"

            return True, None

        except Exception as e:  # pylint: disable=broad-exception-caught
            return False, str(e)

    def test_object_exports(self, obj_info, library_file_name, successful_exports, failed_exports):
        """Test exports for a single object in all formats."""
        obj = obj_info['object']
        obj_name = obj_info['name']
        obj_type = obj_info['type']

        for export_format in self.supported_formats:
            format_name = export_format.extension

            # Skip formats that don't support assemblies
            if (obj_type == 'assembly' and
                export_format.assembly_handler is None):
                continue

            export_key = f"{library_file_name}::{obj_name}::{export_format.name}"

            success, error = self.perform_export_test(
                obj, obj_type, format_name, export_key)

            if success:
                successful_exports.append(export_key)
            else:
                failed_exports.append(f"{export_key}: {error}")

    def test_single_library_file(self, library_file, failed_exports, successful_exports):
        """Test a single library file for export functionality."""
        try:
            # Execute the library file
            execution_result = self.executor.execute_library_file(library_file)
            exportable_objects = self.executor.get_exportable_objects(execution_result)

            if len(exportable_objects) == 0:
                failed_exports.append(f"{library_file.name}: No exportable objects found")
                return

            # Test each object with each format
            for obj_info in exportable_objects:
                self.test_object_exports(obj_info, library_file.name,
                                       successful_exports, failed_exports)

        except Exception as e:  # pylint: disable=broad-exception-caught
            failed_exports.append(f"{library_file.name}: Failed to execute - {str(e)}")

    def report_test_results(self, successful_exports, failed_exports):
        """Report test results."""
        print("\nExport Test Summary:")
        print(f"Successful exports: {len(successful_exports)}")
        print(f"Failed exports: {len(failed_exports)}")

        if successful_exports:
            print("\nSuccessful exports:")
            for success in successful_exports[:10]:  # Show first 10
                print(f"  ✓ {success}")
            if len(successful_exports) > 10:
                print(f"  ... and {len(successful_exports) - 10} more")

        if failed_exports:
            print("\nFailed exports:")
            for failure in failed_exports:
                print(f"  ✗ {failure}")


class TestLibraryExportTester(unittest.TestCase):
    """Tests for LibraryExportTester."""

    def test_library_export_tester_creation(self):
        """Test that LibraryExportTester can be created."""
        library_path = Path(__file__).parent / "library"
        tester = LibraryExportTester(library_path)
        self.assertIsInstance(tester, LibraryExportTester)
        self.assertEqual(tester.library_path, library_path)

    def test_perform_export_test(self):
        """Test export test functionality."""
        library_path = Path(__file__).parent / "library"
        tester = LibraryExportTester(library_path)

        # Test with None object (should fail gracefully)
        success, error = tester.perform_export_test(None, 'shape', 'stl', 'test_key')
        self.assertFalse(success)
        self.assertIsNotNone(error)

    def test_report_test_results(self):
        """Test report functionality."""
        library_path = Path(__file__).parent / "library"
        tester = LibraryExportTester(library_path)

        # Should not raise an exception
        tester.report_test_results([], [])
        tester.report_test_results(['success1'], ['failure1'])
